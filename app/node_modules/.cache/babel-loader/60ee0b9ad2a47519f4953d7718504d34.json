{"ast":null,"code":"'use strict';\n\nvar base32 = require('base32.js');\n\nvar crypto = require('crypto');\n\nvar url = require('url');\n\nvar util = require('util');\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\n\nexports.digest = function digest(options) {\n  var i; // unpack options\n\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase(); // Backwards compatibility - deprecated\n\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  } // convert secret to buffer\n\n\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret) : new Buffer(secret, encoding);\n  } // create an buffer from the counter\n\n\n  var buf = new Buffer(8);\n  var tmp = counter;\n\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff; // shift 8 and get ready to loop over the next batch of 8\n\n    tmp = tmp >> 8;\n  } // init hmac with the key\n\n\n  var hmac = crypto.createHmac(algorithm, secret); // update hmac with the counter\n\n  hmac.update(buf); // return the digest\n\n  return hmac.digest();\n};\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\n\nexports.hotp = function hotpGenerate(options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.'); // digest the options\n\n  var digest = options.digest || exports.digest(options); // compute HOTP offset\n\n  var offset = digest[digest.length - 1] & 0xf; // calculate binary code (RFC4226 5.4)\n\n  var code = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff; // left-pad code\n\n  code = new Array(digits + 1).join('0') + code.toString(10); // return length number off digits\n\n  return code.substr(-digits);\n}; // Alias counter() for hotp()\n\n\nexports.counter = exports.hotp;\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta(options) {\n  var i; // shadow options\n\n  options = Object.create(options); // unpack options\n\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0; // fail if token is not of correct length\n\n  if (token.length !== digits) {\n    return;\n  } // parse token to integer\n\n\n  token = parseInt(token, 10); // fail if token is NA\n\n  if (isNaN(token)) {\n    return;\n  } // loop from C to C + W inclusive\n\n\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i; // domain-specific constant-time comparison for integer codes\n\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {\n        delta: i - counter\n      };\n    }\n  } // no codes have matched\n\n};\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\n\n\nexports.hotp.verify = function hotpVerify(options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\n\nexports._counter = function _counter(options) {\n  var step = options.step || 30;\n  var time = options.time != null ? options.time * 1000 : Date.now(); // also accepts 'initial_time', but deprecated\n\n  var epoch = (options.epoch != null ? options.epoch * 1000 : options.initial_time * 1000) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n  return Math.floor((time - epoch) / step / 1000);\n};\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\n\nexports.totp = function totpGenerate(options) {\n  // shadow options\n  options = Object.create(options); // calculate default counter value\n\n  if (options.counter == null) options.counter = exports._counter(options); // pass to hotp\n\n  return this.hotp(options);\n}; // Alias time() for totp()\n\n\nexports.time = exports.totp;\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta(options) {\n  // shadow options\n  options = Object.create(options); // unpack options\n\n  var window = parseInt(options.window, 10) || 0; // calculate default counter value\n\n  if (options.counter == null) options.counter = exports._counter(options); // adjust for two-sided window\n\n  options.counter -= window;\n  options.window += window; // pass to hotp.verifyDelta\n\n  var delta = exports.hotp.verifyDelta(options); // adjust for two-sided window\n\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\n\n\nexports.totp.verify = function totpVerify(options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\n\n\nexports.generateSecret = function generateSecret(options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true; // turn off symbols only when explicity told to\n\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  } // generate an ascii key\n\n\n  var key = this.generateSecretASCII(length, symbols); // return a SecretKey with ascii, hex, and base32\n\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, ''); // generate some qr codes if requested\n\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  } // add in the Google Authenticator-compatible otpauth URL\n\n\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  } // generate a QR code for use in Google Authenticator if requested\n\n\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({\n      secret: SecretKey.base32,\n      label: name\n    }));\n  }\n\n  return SecretKey;\n}; // Backwards compatibility - generate_key is deprecated\n\n\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\n\nexports.generateSecretASCII = function generateSecretASCII(length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n\n  return output;\n}; // Backwards compatibility - generate_key_ascii is deprecated\n\n\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL(options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii'; // validate type\n\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  } // validate required options\n\n\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label'); // require counter for HOTP\n\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  } // convert secret to base32\n\n\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret); // build query while validating\n\n  var query = {\n    secret: secret\n  };\n  if (issuer) query.issuer = issuer; // validate algorithm\n\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n\n    query.algorithm = algorithm.toUpperCase();\n  } // validate digits\n\n\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n\n    query.digits = digits;\n  } // validate period\n\n\n  if (period != null) {\n    period = parseInt(period, 10);\n\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n\n    query.period = period;\n  } // return url\n\n\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};","map":{"version":3,"sources":["/home/ubuntu/Connor/SandBoxOSU/app/node_modules/speakeasy/index.js"],"names":["base32","require","crypto","url","util","exports","digest","options","i","secret","counter","encoding","algorithm","toLowerCase","key","console","warn","Buffer","isBuffer","decode","buf","tmp","hmac","createHmac","update","hotp","hotpGenerate","digits","length","offset","code","Array","join","toString","substr","verifyDelta","hotpVerifyDelta","Object","create","token","String","parseInt","window","isNaN","delta","verify","hotpVerify","_counter","step","time","Date","now","epoch","initial_time","Math","floor","totp","totpGenerate","totpVerifyDelta","totpVerify","generateSecret","name","encodeURIComponent","qr_codes","google_auth_qr","otpauth_url","symbols","undefined","generateSecretASCII","SecretKey","ascii","hex","encode","replace","qr_code_ascii","qr_code_hex","qr_code_base32","otpauthURL","label","generate_key","deprecate","bytes","randomBytes","set","output","l","generate_key_ascii","issuer","type","period","Error","query","toUpperCase","format","protocol","slashes","hostname","pathname"],"mappings":"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","sourcesContent":["'use strict';\n\nvar base32 = require('base32.js');\nvar crypto = require('crypto');\nvar url = require('url');\nvar util = require('util');\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest (options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret)\n      : new Buffer(secret, encoding);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate (options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 |\n    (digest[offset + 1] & 0xff) << 16 |\n    (digest[offset + 2] & 0xff) << 8 |\n    (digest[offset + 3] & 0xff);\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta (options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {delta: i - counter};\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\nexports.hotp.verify = function hotpVerify (options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter (options) {\n  var step = options.step || 30;\n  var time = options.time != null ? (options.time * 1000) : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\nexports.totp.verify = function totpVerify (options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret (options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({ secret: SecretKey.base32, label: name }));\n  }\n\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII (length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL (options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {secret: secret};\n  if (issuer) query.issuer = issuer;\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};\n"]},"metadata":{},"sourceType":"script"}